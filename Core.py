import loggingimport socketimport timeimport asynciofrom asyncio import sleepfrom Day import Dayimport osfrom datetime import datetime#from ByteStream.Writer import Writerfrom threading import *from Factory import packetsfrom Logic.Player import Playerfrom asyncio import sleepfrom Logic.PacketsHelper import PacketsHelperaddr = []def _(*args):	print('[DEBUG]', end=' ')	for arg in args:		print(arg, end=' ')	print()			class Server:	Clients = {"ClientCounts": 0, "Clients": {}}	ThreadCount = 0	def __init__(self, ip: str, port: int):		self.server = socket.socket()		self.port = port		self.ip = ip	def start(self):		_("Preparing landing area...")		self.server.bind((self.ip, self.port))		_(f'VokesBrawl-v36 started on {self.ip}:{self.port}')		while True:			self.server.listen()			client, address = self.server.accept()			if address[0] not in addr:				_(f'Attach! IP: {address[0]}')				ClientThread(client, address).start()				Server.ThreadCount += 1				addr.append(address[0])			else:				print(f"{address[0]} started a ddos!")				os.system(f"iptables -A INPUT -s {address[0]} -j DROP")#async def proper(client, player):#	await Day(client, player).send()class ClientThread(Thread):	def __init__(self, client, address):		super().__init__()		self.client = client		self.address = address		self.player = Player()	def recvall(self, length: int):		data = b''		while len(data) < length:			s = self.client.recv(length)			if not s:				print("Receive Error!")				break			data += s		return data	def run(self):		last_packet = time.time()		try:			while True:				header = self.client.recv(7)				if len(header) > 0:					last_packet = time.time()					packet_id = int.from_bytes(header[:2], 'big')					length = int.from_bytes(header[2:5], 'big')					packet_name = PacketsHelper.getMessageName(packet_id)					data = self.recvall(length)					if packet_id in packets:						_(f'Packet Land. Id: {packet_id}, Lenght: {length}, Name: {packet_name}.')						message = packets[packet_id](self.client, self.player, data)						message.decode()						message.process()					#	Day(self.client, self.player).send()						if packet_id == 10101:							Server.Clients["Clients"][str(self.player.ID)] = {"SocketInfo": self.client}							Server.Clients["ClientCounts"] = Server.ThreadCount							self.player.ClientOnline = Server.Clients							self.player.OnlinePlayers = Server.ThreadCount					else:						_(f'Add: Id: {packet_id}, Name: {packet_name}')				if time.time() - last_packet > 5:					print(f"[DSC] Ip: {self.address[0]} deattached cus dsc!")					self.client.close()					Server.ThreadCount = Server.ThreadCount - 1					Server.Clients["Clients"][str(self.player.ID)] = {"SocketInfo": None}					addr.remove(self.address[0])					break		except ConnectionAbortedError:			print(f"[DSC] Ip: {self.address[0]} deattached cus abort!")			self.client.close()			addr.remove(self.address[0])		except ConnectionResetError:			print(f"[DSC] Ip: {self.address[0]} deattached cus reset!")			addr.remove(self.address[0])			self.client.close()		except TimeoutError:			print(f"[DSC] Ip: {self.address[0]} deattached cus timeouterror!")			self.client.close()			addr.remove(self.address[0])if __name__ == '__main__':	server = Server('0.0.0.0', 9339)	server.start()#ding(client, address).start()##class Threading(Thread):#    def __init__(self, client, address):#        super().__init__()#        self.client = client#        self.player = Player()#        self.address = address#        #    def recvall(self, length: int):#        data = b''#        while len(data) < length:#            s = self.client.recv(length)#            if not s:#                print("Receive Error!")#                break#            data += s#        return data#    def run(self):#        #last_packet = time.time()#        try:#                while True:#                	header = self.client.recv(7)#                	if len(header) > 0:#                	   last_packet = time.time()#                	   print(last_packet)#                	   packet_id = int.from_bytes(header[:2], 'big')#                	   packet_name = PacketsHelper.getMessageName(packet_id)#                	   length = int.from_bytes(header[2:5], 'big')#                	   data = self.recvall(length)#                	   if packet_id in packets:#                	       _(f'Packet created: Id: {packet_id}, Name: {packet_name}, Lenght: {length}') #                	       message = packets[packet_id](self.client, self.player, data)#                	       message.decode()#                	       message.process()#                	   else:#                	   	_(f'Добавь: ID: {packet_id}, Name: {packet_name}')#                	   if time.time() - last_packet > 0.00001:#                	         	print(f"[DEBUG] Ip: {self.address[0]} dettached!")#                	         	self.client.close()#                	         	break#        except ConnectionAbortedError:#        	print(f"[DEBUG] Ip: {self.address[0]} dettached")#        	self.client.close()#        except ConnectionResetError:#        	print(f"[DEBUG] Ip: {self.address[0]} dettached")#        	self.client.close()#        except TimeoutError:#        	print(f"[DEBUG] Ip: {self.address[0]} dettached")#        	self.client.close()#                        #                #вот бля, я взял ядро с классика и удалил не нужное и таймаут улетел. а когдп полностью скопировал - ы работает...